<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ConnectHub - Private Chat & Groups</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="icons/favicon.ico" type="image/x-icon">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="/socket.io/socket.io.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
    :root {
        --primary-color: #4CAF50; /* Green - Used for App branding/buttons */
        --secondary-color: #388E3C; /* Darker Green */
        --background-color: #f7f9fc;
    }
    /* FIX: Enforce full height and hide body scroll */
    html { height: 100%; }
    body {
        height: 100%;
        overflow: hidden; /* Prevents the whole body from scrolling */
        font-family: 'Inter', sans-serif;
        background-color: var(--background-color);
        margin: 0;
    }

    /* Custom scrollbar for chat history */
    #chat-history::-webkit-scrollbar { width: 6px; }
    #chat-history::-webkit-scrollbar-thumb {
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 3px;
    }

    /* --- CHAT ALIGNMENT --- */

    /* Message container for alignment (used by the loop) */
    .message-container {
        display: flex; /* Enables flexbox alignment */
        margin-bottom: 10px;
    }

    /* Styles for messages sent by the current user (Pushes to the right) */
    .message-container.sent {
        justify-content: flex-end;
    }

    /* Styles for messages received from the other user (Keeps to the left) */
    .message-container.received {
        justify-content: flex-start;
    }

    /* Styles for the message bubble itself */
    .message-bubble {
        /* Mobile Default: Max 85% width for better use of small screens */
        max-width: 85%;
        padding: 10px 14px;
        border-radius: 18px;
        word-wrap: break-word;
        line-height: 1.4;
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.08); /* Subtle shadow */
    }

    /* Adjust max-width for larger screens (e.g., tablet/desktop) */
    @media (min-width: 640px) {
        .message-bubble {
            max-width: 60%;
        }
    }

    /* SENT (My) Message Bubble Style */
    .message-container.sent .message-bubble {
        background-color: var(--primary-color); /* Primary color bubble */
        color: white;
        /* Curved corners for sent messages */
        border-bottom-right-radius: 4px;
    }

    /* RECEIVED (Other) Message Bubble Style */
    .message-container.received .message-bubble {
        background-color: #ffffff; /* White/light gray bubble */
        color: #374151; /* Darker text */
        /* Curved corners for received messages */
        border-bottom-left-radius: 4px;
    }

    .message-time {
        font-size: 0.65rem;
        opacity: 0.8;
        margin-top: 5px;
        display: block;
        text-align: right;
        color: inherit;
    }

    /* Ensure time is white on sent messages */
    .message-container.sent .message-time {
        color: rgba(255, 255, 255, 0.9);
    }

    /* --- MOBILE/TABLET/LARGE SCREEN OPTIMIZATION FIX START --- */

    /* 1. Sidebar Base/Mobile Styles (Full screen takeover, hidden by default) */
    #user-list-sidebar {
        transition: width 0.3s ease, min-width 0.3s ease, transform 0.3s ease;
        transform: translateX(-100%); /* Hidden by default on mobile */
        position: fixed; top: 0; left: 0;
        height: 100vh;
        z-index: 50;
        width: 100%; min-width: 100%; /* Full screen on mobile */
        background-color: white;
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2); /* Shadow for overlay effect */
    }
    /* Mobile: When opened by JS */
    #user-list-sidebar.open {
        transform: translateX(0);
    }
    /* Hide desktop toggle button on mobile */
    #sidebar-toggle-button {
        display: none !important;
    }

    /* 2. Desktop (lg: 1024px) Styles */
    @media (min-width: 1024px) {
        #user-list-sidebar {
            position: static; /* No longer fixed */
            transform: translateX(0); /* Always visible */
            width: 300px; min-width: 300px; /* Fixed width on desktop */
            box-shadow: none; /* No overlay shadow */
            flex-shrink: 0; /* Ensures it doesn't shrink in the flex container */
        }
        /* Hide mobile open/close buttons on desktop */
        #sidebar-open-mobile, #sidebar-close-mobile {
            display: none !important;
        }
        /* Show desktop toggle button */
        #sidebar-toggle-button {
            display: block !important;
        }

        /* Ensure main content takes remaining space (assuming parent is flex) */
        #chat-main {
            flex-grow: 1;
        }
    }

    /* 3. Minimized Sidebar (Desktop only) */
    .sidebar-minimized {
        width: 80px !important;
        min-width: 80px !important;
    }
    .sidebar-minimized .user-name,
    .sidebar-minimized .app-logo,
    .sidebar-minimized .nav-links,
    .sidebar-minimized .unread-badge,
    .sidebar-minimized .tab-selector,
    .sidebar-minimized .member-info {
        display: none;
    }
    .sidebar-minimized .user-avatar {
        margin: 0 auto;
    }
    .sidebar-minimized .user-item {
        padding-left: 0 !important;
        text-align: center;
    }
    .sidebar-minimized .user-item .flex {
        justify-content: center !important;
    }
    .sidebar-minimized .user-item .status-wrapper {
        margin: 0 !important;
    }
    .sidebar-minimized #sidebar-toggle-button i {
        transform: rotate(180deg);
    }

    /* 4. Chat Header Mobile Fix: Move recipient name to left on mobile */
    @media (max-width: 1023px) {
        #chat-header > div.flex {
            width: 100%;
        }
        #recipient-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #add-member-btn {
            flex-shrink: 0;
        }
    }
    /* --- MOBILE/TABLET/LARGE SCREEN OPTIMIZATION FIX END --- */

    /* Custom Tab Styling */
    .tab-button.active {
        border-bottom: 2px solid var(--primary-color);
        color: var(--primary-color);
        font-weight: 600;
    }
    .create-group-button {
        transition: transform 0.2s;
    }
    .create-group-button:hover {
        transform: scale(1.1);
    }

    /* Custom Toast Styles */
    .toast-enter-active, .toast-leave-active { transition: opacity 0.3s, transform 0.3s; }
    .toast-enter-from, .toast-leave-to { opacity: 0; transform: translateY(20px); }

    /* File bubble styling */
    .file-bubble {
        display: flex;
        align-items: center;
        padding: 8px;
        border-radius: 12px;
        background-color: rgba(0, 0, 0, 0.1);
    }
    .message-container.sent .file-bubble {
        background-color: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
    }
    .message-container.received .file-bubble {
        background-color: #f0f4f8;
        border: 1px solid #e0e6ec;
    }
    .file-icon {
        font-size: 24px;
        margin-right: 10px;
        color: var(--primary-color);
    }
    .message-container.sent .file-icon {
        color: #ffffff;
    }
    .file-info a {
        font-weight: 600;
        text-decoration: underline;
    }

    /* --- NEW CALL MODAL STYLES --- */
    #call-modal {
        /* Use a higher z-index than other modals (e.g., 120 is used for others) */
        z-index: 200;
        background-color: #000000; /* Black background */
        transition: opacity 0.3s ease;
    }

    #call-ui-content {
        /* Use a dark, slightly transparent background for the UI elements */
        background-color: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(5px);
    }
    /* Call Button size and color for Hangup/Accept */
    .call-btn {
        width: 80px;
        height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        color: white;
        font-size: 36px;
        transition: opacity 0.2s, transform 0.2s;
    }
    .call-btn:hover {
        transform: scale(1.05);
    }
    #hangup-button {
        background-color: #EF4444; /* Red-500 */
    }
    #accept-button {
        background-color: #10B981; /* Green-500 */
    }

    .caller-avatar {
        width: 120px;
        height: 120px;
        font-size: 48px;
    }
    .status-text {
        font-weight: 500;
        text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    }

    /* Video stream styling */
    #local-video, #remote-video {
        max-width: 45%;
        border: 2px solid white;
    }

</style>
</head>
<body class="min-h-screen flex flex-col">

    <div id="call-modal" class="hidden fixed inset-0 flex items-center justify-center p-4">
        <div id="call-ui-content" class="absolute inset-0 flex flex-col items-center justify-center p-8 text-white">

            <div class="caller-avatar rounded-full bg-gray-500 flex items-center justify-center font-bold mb-6">
                <span id="call-recipient-initial">R</span>
            </div>

            <h2 id="call-recipient-name" class="text-4xl font-bold mb-2 text-center text-shadow-lg">Recipient Name</h2>

            <p id="call-status-text" class="status-text text-xl mb-12 text-gray-200">Calling...</p>

            <div id="video-streams-container" class="mt-8 flex justify-center space-x-4 w-full">
                <video id="local-video" autoplay muted class="w-1/2 h-40 bg-gray-800 rounded-lg shadow-xl hidden object-cover"></video>
                <video id="remote-video" autoplay class="w-1/2 h-40 bg-gray-800 rounded-lg shadow-xl hidden object-cover"></video>
            </div>

            <div id="call-controls" class="flex space-x-10 mt-12">
                <button id="accept-button" class="call-btn hidden" title="Answer Call">
                    <i class="fa fa-phone"></i>
                </button>

                <button id="hangup-button" class="call-btn" onclick="hangUpCall(true)" title="Hang Up">
                    <i class="fa fa-phone-slash"></i>
                </button>
            </div>
        </div>
    </div>
    <div id="create-group-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-[120] flex items-center justify-center p-4">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-md p-6">
            <h3 class="text-2xl font-bold mb-4 text-gray-800 border-b pb-2">Create New Group</h3>
            <p class="text-sm text-gray-500 mb-4">You will be the administrator of this group. You can optionally invite other users now.</p>

            <form id="create-group-form">
                <div class="mb-4">
                    <label for="group-name" class="block text-sm font-medium text-gray-700 mb-1">Group Name</label>
                    <input type="text" id="group-name" required
                           class="w-full p-2 border border-gray-300 rounded-lg focus:ring-primary-color focus:border-primary-color transition duration-150"
                           placeholder="e.g., Project Connect Team">
                </div>
                <div class="mb-6">
                    <label for="group-invites" class="block text-sm font-medium text-gray-700 mb-1">Invite Users (Comma-separated usernames)</label>
                    <input type="text" id="group-invites"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:ring-primary-color focus:border-primary-color transition duration-150"
                           placeholder="userA, userB, userC">
                    <p class="text-xs text-gray-500 mt-1">Users will be added immediately.</p>
                </div>
                <div class="flex justify-end space-x-3">
                    <button type="button" onclick="document.getElementById('create-group-modal').classList.add('hidden')"
                            class="px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition duration-150">
                        Cancel
                    </button>
                    <button type="submit"
                            class="px-4 py-2 bg-primary-color text-white font-semibold rounded-lg hover:bg-secondary-color transition duration-150"
                            style="background-color: var(--primary-color);">
                        Create Group
                    </button>
                </div>
            </form>
        </div>
    </div>

    <div id="add-member-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-[120] flex items-center justify-center p-4">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-md p-6">
            <h3 class="text-2xl font-bold mb-4 text-gray-800 border-b pb-2">Add Members to <span id="add-member-group-name" class="text-primary-color"></span></h3>
            <p class="text-sm text-gray-500 mb-4">Enter the usernames of the users you wish to add.</p>

            <form id="add-member-form">
                <div class="mb-6">
                    <label for="new-members-input" class="block text-sm font-medium text-gray-700 mb-1">Usernames (Comma-separated)</label>
                    <input type="text" id="new-members-input" required
                           class="w-full p-2 border border-gray-300 rounded-lg focus:ring-primary-color focus:border-primary-color transition duration-150"
                           placeholder="userD, userE, userF">
                </div>
                <div class="flex justify-end space-x-3">
                    <button type="button" onclick="document.getElementById('add-member-modal').classList.add('hidden')"
                            class="px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition duration-150">
                        Cancel
                    </button>
                    <button type="submit" id="submit-add-members"
                            class="px-4 py-2 bg-primary-color text-white font-semibold rounded-lg hover:bg-secondary-color transition duration-150"
                            style="background-color: var(--primary-color);">
                        Add Members
                    </button>
                </div>
            </form>
        </div>
    </div>

    <div id="file-picker-container" class="absolute bottom-20 lg:right-28 right-4 bg-white border border-gray-200 rounded-xl shadow-2xl p-4 w-60 z-30 hidden">
        <h4 class="text-sm font-semibold text-gray-600 mb-2 border-b pb-1">Send File</h4>
        <div class="space-y-1">
            <label class="file-picker-item cursor-pointer text-gray-700">
                <i class="fa fa-image text-xl mr-3 text-blue-500"></i>
                <span class="font-medium">Image (All Types)</span>
                <input type="file" id="file-input-image" accept="image/*" class="hidden" onchange="uploadFileAndSendMessage(event)">
            </label>
            <label class="file-picker-item cursor-pointer text-gray-700">
                <i class="fa fa-file-alt text-xl mr-3 text-green-500"></i>
                <span class="font-medium">Document</span>
                <input type="file" id="file-input-document" accept=".pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt" class="hidden" onchange="uploadFileAndSendMessage(event)">
            </label>
            <label class="file-picker-item cursor-pointer text-gray-700">
                <i class="fa fa-video text-xl mr-3 text-red-500"></i>
                <span class="font-medium">Video</span>
                <input type="file" id="file-input-video" accept="video/*" class="hidden" onchange="uploadFileAndSendMessage(event)">
            </label>
            <label class="file-picker-item cursor-pointer text-gray-700">
                <i class="fa fa-volume-up text-xl mr-3 text-purple-500"></i>
                <span class="font-medium">Audio</span>
                <input type="file" id="file-input-audio" accept="audio/*" class="hidden" onchange="uploadFileAndSendMessage(event)">
            </label>
        </div>
    </div>

    <div id="emoji-picker-container" class="absolute bottom-20 lg:right-5 right-16 bg-white border border-gray-200 rounded-xl shadow-2xl p-4 w-60 h-80 z-30 hidden">
        <h4 class="text-sm font-semibold text-gray-600 mb-2 border-b pb-1">Select Emoji</h4>
        <div id="emoji-list" class="flex flex-wrap gap-2 text-2xl overflow-y-auto h-[calc(100%-30px)]">
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('üòé')">üòé</span>
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('üëç')">üëç</span>
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('üòÅ')">üòÅ</span>
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('üòÇ')">üòÇ</span>
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('üôå')">üôå</span>
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('‚úî')">‚úî</span>
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('üòú')">üòú</span>
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('üòí')">üòí</span>
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('üò¢')">üò¢</span>
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('üòò')">üòò</span>
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('‚ù§')">‚ù§</span>
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('üòÉ')">üòÉ</span>
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('üòä')">üòä</span>
            <span class="cursor-pointer hover:bg-gray-100 p-1 rounded transition duration-100" onclick="insertEmoji('‚úå')">‚úå</span>
        </div>
    </div>


    <div id="toast-container" class="fixed bottom-5 right-5 z-[110] space-y-2"></div>
    <div id="loading-screen" class="fixed inset-0 bg-gray-50 flex items-center justify-center z-[100] transition-opacity duration-500">
        <div class="text-xl font-semibold text-gray-700">Checking session.</div>
    </div>
    <div id="login-redirect" class="hidden fixed inset-0 bg-white z-[101] flex flex-col items-center justify-center p-8">
        <div class="max-w-md w-full bg-white rounded-xl p-8 shadow-2xl text-center">
            <i class="fa fa-lock text-5xl text-red-500 mb-4"></i>
            <h1 class="text-3xl font-bold mb-4 text-gray-800">Access Denied</h1>
            <p class="text-gray-600 mb-6">You must be logged in to access the private chat. Please log in or sign up.</p>
            <a href="/" class="px-6 py-3 bg-primary-color hover:bg-secondary-color text-white font-semibold rounded-lg shadow-md transition duration-200" style="background-color: var(--primary-color);">Go to Login Page</a>
        </div>
    </div>

    <div id="chat-app" class="flex flex-1 hidden h-full">
        <div id="user-list-sidebar" class="bg-white border-r border-gray-200 flex-shrink-0 flex flex-col shadow-xl lg:shadow-none h-full">
            <div class="p-4 flex items-center justify-between border-b border-gray-100">
                <h1 class="text-2xl font-bold text-primary-color app-logo" style="color: var(--primary-color);">ConnectHub</h1>

                <button id="sidebar-toggle-button" class="hidden lg:block p-2 rounded-full hover:bg-gray-100 transition duration-150 text-gray-600">
                    <i class="fa fa-bars text-xl"></i>
                </button>
                <button id="sidebar-close-mobile" class="lg:hidden p-2 rounded-full hover:bg-gray-100 transition duration-150 text-gray-600">
                    <i class="fa fa-times text-2xl"></i>
                </button>
            </div>

            <div class="p-4 border-b border-gray-100 nav-links">
                <a href="/" class="block mb-2 px-3 py-2 rounded-lg text-gray-700 hover:bg-gray-100 transition duration-150">
                    <i class="fa fa-house w-6"></i> Community Posts
                </a>
                <button id="logout-button" class="w-full text-left px-3 py-2 rounded-lg text-red-500 hover:bg-red-50 transition duration-150">
                    <i class="fa fa-sign-out-alt w-6"></i> Log Out (<span id="current-user-display">...</span>)</button>
            </div>

            <div id="sidebar-tabs" class="flex border-b border-gray-200 tab-selector">
                <button id="tab-users" class="tab-button flex-1 p-3 text-sm text-center text-gray-500 hover:bg-gray-50 transition duration-150 active"
                    onclick="setCurrentView('users')">
                    <i class="fa fa-user-friends mr-1"></i> Users
                </button>
                <button id="tab-groups" class="tab-button flex-1 p-3 text-sm text-center text-gray-500 hover:bg-gray-50 transition duration-150"
                    onclick="setCurrentView('groups')">
                    <i class="fa fa-users-rectangle mr-1"></i> Groups
                </button>
            </div>

            <div class="flex-1 overflow-y-auto p-2">
                <div id="sidebar-list-header" class="flex items-center justify-between px-2 py-1 mb-2 border-b">
                    <p id="sidebar-list-title" class="text-xs text-gray-400 font-semibold uppercase">All Users</p>
                    <button id="create-group-btn" onclick="showCreateGroupModal()" title="Create New Group"
                            class="create-group-button text-primary-color hover:text-secondary-color hidden p-1 rounded-full text-lg transition duration-200">
                        <i class="fa fa-plus"></i>
                    </button>
                </div>

                <div id="sidebar-list-container">
                    <p class="text-center text-gray-500 p-4">Loading content...</p>
                </div>
            </div>

        </div>

        <div id="chat-main" class="flex flex-col flex-1 h-full relative">
            <div id="chat-header" class="bg-white p-4 border-b border-gray-200 shadow-md flex items-center justify-between">
                <div class="flex items-center flex-1 min-w-0"> <button id="sidebar-open-mobile" class="lg:hidden p-2 rounded-full hover:bg-gray-100 transition duration-150 text-gray-600">
                        <i class="fa fa-users text-xl"></i>
                    </button>
                    <h2 id="recipient-name" class="text-xl font-semibold text-gray-800 ml-3 truncate">Select a user or group to chat</h2>
                </div>

                <button type="button" id="voice-call-btn" class="p-2 rounded-full text-primary-color hover:bg-gray-100 transition duration-150 flex-shrink-0 disabled:opacity-50 disabled:pointer-events-none"
                        onclick="startVoiceCall()" title="Start Voice Call" disabled>
                    <i class="fa fa-phone text-xl"></i>
                </button>

                <button type="button" id="video-call-btn" class="ml-2 p-2 rounded-full text-primary-color hover:bg-gray-100 transition duration-150 flex-shrink-0 disabled:opacity-50 disabled:pointer-events-none"
                        onclick="startVideoCall()" title="Start Video Call" disabled>
                    <i class="fa fa-video text-xl"></i>
                </button>

                <button id="add-member-btn" class="hidden ml-2 p-2 rounded-full text-primary-color hover:bg-gray-100 transition duration-150 flex-shrink-0"
                        onclick="showAddMemberModal()" title="Add Members to Group">
                    <i class="fa fa-user-plus text-xl"></i>
                </button>
            </div>

            <div id="chat-history" class="flex-1 overflow-y-auto p-6 space-y-4 bg-background-color">
                <p class="text-center text-gray-500 text-lg p-10">
                    <i class="fa fa-comment-dots text-4xl text-gray-300 block mb-2"></i>
                    Your conversations will appear here.
                </p>
            </div>

            <form id="message-form" class="bg-white p-4 border-t border-gray-200 flex items-center">
                <button type="button" id="emoji-button" onclick="toggleEmojiPicker()"
                        class="p-3 rounded-full text-gray-500 hover:bg-gray-100 transition duration-150 disabled:opacity-50"
                        title="Add Emoji" disabled>
                    <i class="fa-regular fa-face-smile text-xl"></i>
                </button>

                <button type="button" id="file-button" onclick="toggleFilePicker()"
                        class="p-3 rounded-full text-gray-500 hover:bg-gray-100 transition duration-150 disabled:opacity-50"
                        title="Attach File" disabled>
                    <i class="fa fa-paperclip text-xl"></i>
                </button>

                <input type="text" id="message-input" placeholder="Type your message..."
                        class="flex-1 p-3 border border-gray-300 rounded-lg focus:ring-primary-color focus:border-primary-color transition duration-150 disabled:bg-gray-100 mx-2"
                        style="border-color: var(--primary-color);" disabled>

                <button type="submit" id="send-button"
                            class="ml-2 px-5 py-3 bg-primary-color text-white font-semibold rounded-lg hover:bg-secondary-color transition duration-150 disabled:bg-gray-400"
                            style="background-color: var(--primary-color);" disabled>
                    <i class="fa fa-paper-plane"></i>
                </button>
            </form>

        </div>
    </div>

    <script>
        // --- GLOBAL VARIABLES & INITIALIZATION ---
        const currentUsername = localStorage.getItem('username'); // Logged in user's username
        let currentUserId = null; // Logged in user's ID from DB
        let currentRecipient = null; // Username or ID of the user/group currently chatting with

        let messagePollInterval = null; // Polling handle for message history
        const POLL_RATE = 2000; // Poll for new messages every 2 seconds

        const loadingScreen = document.getElementById('loading-screen');
        const loginRedirect = document.getElementById('login-redirect');
        const chatApp = document.getElementById('chat-app');
        const currentUserDisplayEl = document.getElementById('current-user-display');

        const chatHistory = document.getElementById('chat-history');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const sidebarListContainer = document.getElementById('sidebar-list-container');
        const sidebarListTitle = document.getElementById('sidebar-list-title');
        const createGroupBtn = document.getElementById('create-group-btn');
        const recipientNameEl = document.getElementById('recipient-name');
        const toastContainer = document.getElementById('toast-container');
        const createGroupModal = document.getElementById('create-group-modal');

        const addMemberBtn = document.getElementById('add-member-btn');
        const addMemberGroupNameEl = document.getElementById('add-member-group-name');
        const addMemberModal = document.getElementById('add-member-modal');

        // NEW GLOBAL STATE ELEMENTS
        const emojiPickerContainer = document.getElementById('emoji-picker-container');
        const filePickerContainer = document.getElementById('file-picker-container');
        const emojiButton = document.getElementById('emoji-button');
        const fileButton = document.getElementById('file-button');
        const messageForm = document.getElementById('message-form');

        // NEW CALL BUTTONS
        const voiceCallBtn = document.getElementById('voice-call-btn');
        const videoCallBtn = document.getElementById('video-call-btn');

        // NEW CALL UI ELEMENTS
        const callModal = document.getElementById('call-modal');
        const callRecipientInitialEl = document.getElementById('call-recipient-initial');
        const callRecipientNameEl = document.getElementById('call-recipient-name');
        const callStatusTextEl = document.getElementById('call-status-text');
        const acceptButton = document.getElementById('accept-button');
        const hangupButton = document.getElementById('hangup-button');
        const localVideoEl = document.getElementById('local-video');
        const remoteVideoEl = document.getElementById('remote-video');
        
        // NEW WEBRTC STATE AND CONFIG
        let localStream = null;
        let peerConnection = null;
        const iceServers = {
            'iceServers': [
                { 'urls': 'stun:stun.l.google.com:19302' },
            ]
        };

        let callState = {
            active: false,
            recipient: null,
            type: null,
            isIncoming: false
        };

        let registeredUserList = []; // Full list of all users from the DB
        let onlineUsernamesList = []; // Array of currently connected usernames (Socket.IO)
        let unreadCounts = {}; // Map: { username/groupId: count }
        let groupsList = []; // List of available groups from DB
        let currentView = 'users'; // 'users' or 'groups'

        // Initialize Socket.IO connection
        const socket = io();


        // --- NEW CALL UI & LOGIC FUNCTIONS ---

        // NEW: Function to set up the RTCPeerConnection
        function setupPeerConnection(recipientUsername, callType, isIncoming) {
            // Clean up existing connection if it somehow remains
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            peerConnection = new RTCPeerConnection(iceServers);

            // 1. Handle ICE Candidates: Send them to the other user via the server
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice:candidate', {
                        to: recipientUsername,
                        from: currentUsername,
                        candidate: event.candidate,
                    });
                }
            };

            // 2. Handle Remote Stream: Attach the remote user's media stream to the remote video element
            peerConnection.ontrack = (event) => {
                console.log('Received remote track:', event.track.kind);
                if (remoteVideoEl.srcObject !== event.streams[0]) {
                    remoteVideoEl.srcObject = event.streams[0];
                    remoteVideoEl.classList.remove('hidden');
                    console.log('Remote stream attached.');
                }
            };

            // 3. Add Local Stream Tracks
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
            }

            return peerConnection;
        }

        // NEW: Utility function to get local media stream
        async function startLocalStream(callType) {
            const constraints = {
                audio: true,
                video: callType === 'video' ? { width: 640, height: 480 } : false
            };

            try {
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideoEl.srcObject = localStream;
                localVideoEl.classList.remove('hidden');
                return localStream;
            } catch (err) {
                console.error("Failed to get local stream:", err);
                throw err;
            }
        }


        function showCallUI(recipientName, callType, isIncoming) {
            if (callState.active) {
                showToast("Already in a call or calling.", 'error');
                return;
            }

            callState = {
                active: true,
                recipient: recipientName,
                type: callType,
                isIncoming: isIncoming
            };

            callRecipientNameEl.textContent = recipientName;
            callRecipientInitialEl.textContent = recipientName[0].toUpperCase();
            
            // Set status text and button visibility based on call type (Voice/Video)
            const typeText = callType.charAt(0).toUpperCase() + callType.slice(1);

            // Control video visibility
            if (callType === 'video') {
                localVideoEl.classList.remove('hidden');
                remoteVideoEl.classList.remove('hidden');
            } else {
                // For voice calls, hide video elements (local stream still used for audio)
                localVideoEl.classList.add('hidden');
                remoteVideoEl.classList.add('hidden');
            }

            if (isIncoming) {
                callStatusTextEl.textContent = `Incoming ${typeText} Call...`;
                acceptButton.classList.remove('hidden');
                acceptButton.onclick = async () => {
                    try {
                        // 1. Get the stream and set up the peer connection
                        await startLocalStream(callType);
                        setupPeerConnection(callState.recipient, callType, true);

                        // 2. Signal server that we are ready to receive the offer
                        socket.emit('call:ready_to_receive', { 
                            from: currentUsername, 
                            to: callState.recipient 
                        });

                        // 3. Update UI
                        acceptButton.classList.add('hidden');
                        callStatusTextEl.textContent = `${typeText} Call Active`;
                    } catch (err) {
                        const message = err.name === "NotAllowedError" ? "Permission denied. Call failed." : "Microphone/Camera access failed.";
                        hideCallUI(message, 'error', 4000);
                    }
                };
                hangupButton.onclick = () => hangUpCall(true); // Callee hangs up
            } else {
                callStatusTextEl.textContent = `Calling ${recipientName} (${typeText} Call)...`;
                acceptButton.classList.add('hidden');
                hangupButton.onclick = () => hangUpCall(false); // Caller hangs up
            }

            callModal.classList.remove('hidden');
            // Disable chat controls while in call UI
            toggleControls(true);
            voiceCallBtn.disabled = true;
            videoCallBtn.disabled = true;
        }

        function hideCallUI(message = "Call ended.", type = 'info', duration = 3000) {
            if (!callState.active) return; // Prevent double hiding

            // 1. Clean up WebRTC connection and streams
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            localVideoEl.srcObject = null;
            remoteVideoEl.srcObject = null;
            localVideoEl.classList.add('hidden');
            remoteVideoEl.classList.add('hidden');

            callState = {
                active: false,
                recipient: null,
                type: null,
                isIncoming: false
            };
            callModal.classList.add('hidden');
            showToast(message, type, duration);

            // Re-enable chat controls based on current recipient
            toggleControls(false); 
        }

        function hangUpCall(isIncoming) {
            // Determine the correct recipient and event name
            let recipientUsername = isIncoming ? callState.recipient : currentRecipient;
            let message = isIncoming ? "Call declined." : "Call ended.";

            // Emit signal to the other user
            socket.emit('call:end', { to: recipientUsername, from: currentUsername });
            hideCallUI(message, 'info');
        }

        /**
         * Starts a Voice Call.
         */
        async function startVoiceCall() {
            if (!currentRecipient || groupsList.some(g => g.group_id.toString() === currentRecipient)) {
                showToast("Voice calls are only supported for private chats.", 'error',4000);
                return;
            }
            const recipientName = recipientNameEl.textContent;
            voiceCallBtn.disabled = true;

            try {
                showToast("Requesting microphone permission...", 'info', 3000);
                await startLocalStream('voice'); // 1. Get audio stream

                showCallUI(recipientName, 'voice', false); // 2. Show Call UI

                setupPeerConnection(currentRecipient, 'voice', false); // 3. Set up Peer Connection

                const offer = await peerConnection.createOffer(); // 4. Create Offer
                await peerConnection.setLocalDescription(offer);

                const callPayload = {
                    from: currentUsername,
                    to: currentRecipient,
                    sdp: peerConnection.localDescription, // Include SDP offer
                    callType: 'voice'
                };

                // 5. Initiate Call Signaling (sends offer)
                socket.emit('call:start_voice', callPayload, (response) => {
                    if (response && response.success === false) {
                        hideCallUI(`Call failed: ${response.message}`, 'error');
                    }
                });

            } catch (err) {
                console.error("Voice Call Error:", err);
                let message = "Could not access microphone.";
                if (err.name === "NotAllowedError") {
                    message = "Microphone access denied. Please allow permissions in your browser settings.";
                } else if (err.name === "NotFoundError") {
                    message = "No microphone found on this device.";
                }
                voiceCallBtn.disabled = false;
                hideCallUI(`Voice Call Failed: ${message}`, 'error', 4000);
            }
        }

        /**
         * Starts a Video Call.
         */
        async function startVideoCall() {
            if (!currentRecipient || groupsList.some(g => g.group_id.toString() === currentRecipient)) {
                showToast("Video calls are only supported for private chats.", 'error',4000);
                return;
            }
            const recipientName = recipientNameEl.textContent;
            videoCallBtn.disabled = true;

            try {
                showToast("Requesting camera and microphone permission...", 'info', 3000);
                await startLocalStream('video'); // 1. Get video stream

                showCallUI(recipientName, 'video', false); // 2. Show Call UI

                setupPeerConnection(currentRecipient, 'video', false); // 3. Set up Peer Connection

                const offer = await peerConnection.createOffer(); // 4. Create Offer
                await peerConnection.setLocalDescription(offer);

                const callPayload = {
                    from: currentUsername,
                    to: currentRecipient,
                    sdp: peerConnection.localDescription, // Include SDP offer
                    callType: 'video'
                };

                // 5. Initiate Call Signaling (sends offer)
                socket.emit('call:start_video', callPayload, (response) => {
                    if (response && response.success === false) {
                        hideCallUI(`Call failed: ${response.message}`, 'error');
                    }
                });

            } catch (err) {
                console.error("Video Call Error:", err);
                let message = "Could not access camera or microphone.";
                if (err.name === "NotAllowedError") {
                    message = "Camera/Mic access denied. Please allow permissions in your browser settings.";
                } else if (err.name === "NotFoundError") {
                    message = "No camera or microphone found on this device.";
                }
                videoCallBtn.disabled = false;
                hideCallUI(`Video Call Failed: ${message}`, 'error', 4000);
            }
        }

        // --- NEW FILE & EMOJI UI FUNCTIONS (Unchanged) ---
        function toggleEmojiPicker() {
            // Close file picker if open
            if (!filePickerContainer.classList.contains('hidden')) {
                filePickerContainer.classList.add('hidden');
            }
            emojiPickerContainer.classList.toggle('hidden');
        }

        function toggleFilePicker() {
            // Close emoji picker if open
            if (!emojiPickerContainer.classList.contains('hidden')) {
                emojiPickerContainer.classList.add('hidden');
            }
            filePickerContainer.classList.toggle('hidden');
        }

        function insertEmoji(emoji) {
            const start = messageInput.selectionStart;
            const end = messageInput.selectionEnd;
            const value = messageInput.value;

            // Insert emoji at cursor position
            messageInput.value = value.substring(0, start) + emoji + value.substring(end);
            
            // Move cursor after the inserted emoji
            messageInput.selectionStart = messageInput.selectionEnd = start + emoji.length;
            messageInput.focus();

            // Close the picker immediately
            emojiPickerContainer.classList.add('hidden');
        }

        // Disables controls during file upload/send process or call active
        function toggleControls(disable) {
            messageInput.disabled = disable;
            sendButton.disabled = disable;
            emojiButton.disabled = disable;
            fileButton.disabled = disable;

            // NEW: Call buttons are controlled by `startChat` / `callState` to ensure they enable correctly
            if (!callState.active) {
                voiceCallBtn.disabled = disable || (currentRecipient && groupsList.some(g => g.group_id.toString() === currentRecipient));
                videoCallBtn.disabled = disable || (currentRecipient && groupsList.some(g => g.group_id.toString() === currentRecipient));
            }
        }


        // --- FILE UPLOAD/SEND LOGIC ---

        // Called when a file is selected from the picker's file input
        async function uploadFileAndSendMessage(event) {
            toggleFilePicker(); // Close the picker
            toggleControls(true); // Disable controls during upload/send
            
            const file = event.target.files[0];
            if (!file) {
                toggleControls(false);
                return;
            }

            const isGroup = groupsList.some(g => g.group_id.toString() === currentRecipient);
            
            // Get message content, falling back to a file placeholder if no text is entered
            const content = messageInput.value.trim() || `[File: ${file.name}]`; 

            const formData = new FormData();
            formData.append('file', file);
            formData.append('username', currentUsername);
            formData.append('recipientUsernameOrId', currentRecipient);
            formData.append('isGroup', isGroup.toString());

            renderOptimisticMessage(content, file.name, file.type);
            messageInput.value = '';

            try {
                // 1. Upload the file
                const uploadResponse = await fetch('/api/upload/file', { 
                    method: 'POST', 
                    body: formData 
                });

                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    let errorMessage = `HTTP error! status: ${uploadResponse.status} - ${errorText.substring(0, 50)}...`;
                    try {
                        const errorJson = JSON.parse(errorText);
                        errorMessage = errorJson.message || errorMessage;
                    } catch (e) { /* ignore */ }
                    throw new Error(errorMessage);
                }

                const uploadData = await uploadResponse.json();
                if (!uploadData.success || !uploadData.file_id) {
                    throw new Error(uploadData.message || 'File upload failed: No file ID returned.');
                }
                
                showToast(`File uploaded! Sending message...`, 'success', 3000);

                // 2. Send the message with file metadata via Socket.IO
                const messagePayload = {
                    from: currentUsername,
                    to: currentRecipient,
                    content: content,
                    fileId: uploadData.file_id,
                    messageType: 'file'
                };

                if (isGroup) {
                    socket.emit('group:send_message', messagePayload);
                } else {
                    socket.emit('chat:send_message', messagePayload);
                }

            } catch (error) {
                showToast(`File upload failed! ${error.message}`, 'error', 5000);
                const optimisticBubble = chatHistory.querySelector('[data-optimistic="true"]');
                if (optimisticBubble) optimisticBubble.remove();
            } finally {
                event.target.value = null;
                toggleControls(false); // Re-enable controls
            }
        }


        // --- UTILITY FUNCTIONS (Unchanged) ---
        function showToast(message, type = 'success', duration = 3000) {
            const colors = {
                success: { bg: 'bg-green-500', icon: 'fa-check-circle' },
                error: { bg: 'bg-red-500', icon: 'fa-times-circle' },
                info: { bg: 'bg-blue-500', icon: 'fa-info-circle' }
            };
            const { bg, icon } = colors[type] || colors.info;
            const toastId = `toast-${Date.now()}`;

            const toastHTML = `
                <div id="${toastId}" class="toast-enter-from transition-all duration-300 transform translate-y-5 opacity-0
                                    flex items-center p-4 rounded-lg shadow-xl text-white ${bg}" role="alert">
                    <i class="fa ${icon} mr-2"></i>
                    <div class="text-sm font-medium">${message}</div>
                </div>
            `;
            toastContainer.insertAdjacentHTML('beforeend', toastHTML);
            const toast = document.getElementById(toastId);

            // Animate in
            setTimeout(() => {
                toast.classList.remove('toast-enter-from');
                toast.classList.add('toast-enter-active');
                toast.style.transform = 'translateY(0)';
                toast.style.opacity = '1';
            }, 10); // Small delay to ensure transition works

            // Animate out and remove
            setTimeout(() => {
                toast.style.transform = 'translateY(20px)';
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300); // Remove after transition
            }, duration);
        }

        async function postMessage(content) {
            const isGroup = groupsList.some(g => g.group_id.toString() === currentRecipient);
            const payload = {
                from: currentUsername,
                to: currentRecipient,
                content: content,
                messageType: 'text'
            };

            try {
                if (isGroup) {
                    socket.emit('group:send_message', payload);
                } else {
                    socket.emit('chat:send_message', payload);
                }
                return true;
            } catch (error) {
                console.error("Error sending message:", error);
                showToast("Failed to send message. Network error.", 'error');
                return false;
            }
        }

        // Utility to determine a font-awesome icon based on file mime type
        function getFileIcon(mimeType) {
            if (mimeType.startsWith('image/')) {
                return { icon: 'fa-image', color: 'text-blue-500' };
            } else if (mimeType.startsWith('video/')) {
                return { icon: 'fa-video', color: 'text-red-500' };
            } else if (mimeType.startsWith('audio/')) {
                return { icon: 'fa-volume-up', color: 'text-purple-500' };
            } else if (mimeType.includes('pdf')) {
                return { icon: 'fa-file-pdf', color: 'text-red-600' };
            } else if (mimeType.includes('spreadsheet') || mimeType.includes('excel')) {
                return { icon: 'fa-file-excel', color: 'text-green-600' };
            } else if (mimeType.includes('document') || mimeType.includes('word') || mimeType.includes('text')) {
                return { icon: 'fa-file-word', color: 'text-blue-600' };
            } else {
                return { icon: 'fa-file-alt', color: 'text-gray-500' };
            }
        }

        /**
         * Renders an optimistic message (file or text) while waiting for server confirmation.
         */
        function renderOptimisticMessage(content, filename = null, mimeType = null) {
            const containerClass = 'message-container sent';
            const messageClass = 'message-bubble opacity-70';
            const time = 'Sending...';
            const isFile = filename && mimeType;

            const initialPrompt = chatHistory.querySelector('.text-center.text-lg.p-10');
            if (initialPrompt) initialPrompt.remove();

            let messageContentHTML;
            if (isFile) {
                const { icon } = getFileIcon(mimeType);
                messageContentHTML = `
                    <div class="file-bubble">
                        <i class="fa ${icon} file-icon"></i>
                        <div class="file-info text-white">
                            <p class="truncate">${filename}</p>
                            ${content !== `[File: ${filename}]` ? `<p class="text-xs mt-1 opacity-80">${content}</p>` : ''} 
                        </div>
                    </div>
                `;
            } else {
                messageContentHTML = `<p>${content}</p>`;
            }

            chatHistory.innerHTML += `
                <div class="${containerClass}" data-optimistic="true">
                    <div class="${messageClass}">
                        ${messageContentHTML}
                        <span class="message-time">${time}</span>
                    </div>
                </div>
            `;
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }


        // --- RENDERING FUNCTIONS ---
        function formatMessageTimestamp(timestamp) {
            const now = new Date();
            const date = new Date(timestamp);
            const diffDays = Math.ceil((now - date) / (1000 * 60 * 60 * 24));

            if (diffDays <= 1 && now.getDate() === date.getDate()) {
                // Today: just the time
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } else if (diffDays <= 2 && now.getDate() - 1 === date.getDate()) {
                // Yesterday
                return 'Yesterday ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } else if (diffDays < 7) {
                // Last 7 days: day of the week and time
                return date.toLocaleDateString([], { weekday: 'short' }) + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } else {
                // Older: full date
                return date.toLocaleDateString();
            }
        }

        function renderMessages(messages, isGroup) {
            const wasAtBottom = chatHistory.scrollHeight - chatHistory.scrollTop === chatHistory.clientHeight;
            chatHistory.innerHTML = '';
            
            const initialPrompt = chatHistory.querySelector('.text-center.text-lg.p-10');
            if (initialPrompt) initialPrompt.remove();
            
            if (messages.length === 0) {
                chatHistory.innerHTML = `<p class="text-center text-gray-500 text-lg p-10">
                    <i class="fa fa-comment-dots text-4xl text-gray-300 block mb-2"></i>
                    Start a conversation!
                </p>`;
                return;
            }

            messages.forEach(msg => {
                const isMine = msg.sender_username === currentUsername;
                const containerClass = `message-container ${isMine ? 'sent' : 'received'}`;
                const bubbleClass = 'message-bubble';
                const time = formatMessageTimestamp(msg.timestamp);

                let senderDisplay = '';
                if (isGroup && !isMine) {
                    senderDisplay = `<p class="text-xs font-semibold mb-1 ${isMine ? 'text-white' : 'text-primary-color'}">${msg.sender_username}</p>`;
                }

                let messageContentHTML;

                if (msg.message_type === 'file' && msg.storage_path) {
                    const { icon, color } = getFileIcon(msg.mime_type);
                    const fileUrl = `/uploads/${msg.storage_path}`;
                    let filePreview = '';

                    // Display image preview inline
                    if (msg.mime_type && msg.mime_type.startsWith('image/')) {
                        filePreview = `<img src="${fileUrl}" alt="${msg.original_filename}" class="max-w-full rounded-lg mb-2 shadow-md" style="max-height: 250px;">`;
                    }

                    messageContentHTML = `
                        ${filePreview}
                        <div class="file-bubble">
                            <i class="fa ${icon} file-icon ${isMine ? 'text-white' : color}"></i>
                            <div class="file-info ${isMine ? 'text-white' : 'text-gray-700'}">
                                <a href="${fileUrl}" target="_blank" class="block truncate hover:opacity-80 transition duration-150">
                                    ${msg.original_filename}
                                </a>
                                ${msg.content && msg.content !== `[File: ${msg.original_filename}]` ? `<p class="text-xs mt-1 opacity-90">${msg.content}</p>` : ''}
                            </div>
                        </div>
                    `;
                } else {
                    messageContentHTML = `<p>${msg.content}</p>`;
                }

                chatHistory.innerHTML += `
                    <div class="${containerClass}">
                        <div class="${bubbleClass}">
                            ${senderDisplay}
                            ${messageContentHTML}
                            <span class="message-time">${time}</span>
                        </div>
                    </div>
                `;
            });

            if (wasAtBottom) {
                chatHistory.scrollTop = chatHistory.scrollHeight;
            }
        }

        function renderSidebarContent() {
            sidebarListContainer.innerHTML = '';
            if (currentView === 'users') {
                sidebarListTitle.textContent = 'All Users';
                renderUserList();
            } else if (currentView === 'groups') {
                sidebarListTitle.textContent = 'My Groups';
                renderGroupList();
            }
        }

        function renderUserList() {
            const updatedUsers = registeredUserList.map(user => ({
                ...user,
                isOnline: onlineUsernamesList.includes(user.username)
            })).sort((a, b) => {
                // Sort by online status (online first), then alphabetically
                if (a.isOnline !== b.isOnline) {
                    return a.isOnline ? -1 : 1;
                }
                return a.username.localeCompare(b.username);
            });

            if (updatedUsers.length === 0) {
                sidebarListContainer.innerHTML = `<p class="text-center text-gray-500 p-4">No other users registered.</p>`;
                return;
            }

            sidebarListContainer.innerHTML = updatedUsers.map(user => {
                const username = user.username;
                const statusColor = user.isOnline ? 'bg-green-500' : 'bg-gray-400';
                const isSelected = username === currentRecipient ? 'bg-gray-200' : 'hover:bg-gray-100';
                const unreadCount = unreadCounts[username] || 0;
                const badge = unreadCount > 0 ? `<span class="unread-badge ml-auto px-2 py-0.5 text-xs font-bold text-white bg-red-500 rounded-full">${unreadCount}</span>` : `<span class="unread-badge ml-auto w-6"></span>`;

                return `
                    <div data-type="user" data-id="${username}" class="user-item flex items-center p-3 my-2 cursor-pointer rounded-xl transition duration-150 ${isSelected}">
                        <div class="status-wrapper relative w-10 h-10 flex-shrink-0">
                            <div class="user-avatar w-full h-full rounded-full bg-gray-400 flex items-center justify-center text-white text-lg font-bold">
                                ${username[0].toUpperCase()}
                            </div>
                            <div title="${user.isOnline ? 'Online' : 'Offline'}" class="absolute bottom-0 right-0 w-3 h-3 rounded-full border-2 border-white ${statusColor}"></div>
                        </div>
                        <span class="user-name ml-3 text-gray-800 font-semibold truncate flex-1">${username}</span>
                        ${badge}
                    </div>
                `;
            }).join('');

            document.querySelectorAll('.user-item[data-type="user"]').forEach(item => {
                item.addEventListener('click', () => {
                    startChat(item.dataset.id, 'user', item.dataset.id);
                });
            });
        }


        function renderGroupList() {
            createGroupBtn.classList.remove('hidden');

            if (groupsList.length === 0) {
                sidebarListContainer.innerHTML = `<p class="text-center text-gray-500 p-4">You are not a member of any groups. Click the '+' button to create one!</p>`;
                return;
            }

            sidebarListContainer.innerHTML = groupsList.map(group => {
                const groupId = group.group_id.toString();
                const isSelected = groupId === currentRecipient ? 'bg-gray-200' : 'hover:bg-gray-100';
                const unreadCount = unreadCounts[groupId] || 0;
                const badge = unreadCount > 0 ? `<span class="unread-badge ml-auto px-2 py-0.5 text-xs font-bold text-white bg-red-500 rounded-full">${unreadCount}</span>` : `<span class="unread-badge ml-auto w-6"></span>`;
                const memberCountText = group.member_count ? `${group.member_count} members` : '...members';
                const lastActivity = group.last_activity ? new Date(group.last_activity).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'Never';

                return `
                    <div data-type="group" data-id="${groupId}" data-name="${group.group_name}" class="user-item flex items-center p-3 my-2 cursor-pointer rounded-xl transition duration-150 ${isSelected}">
                        <div class="status-wrapper relative w-10 h-10 flex-shrink-0">
                            <div class="user-avatar w-full h-full rounded-full bg-gray-400 flex items-center justify-center text-white text-lg font-bold">
                                <i class="fa fa-users-rectangle text-sm"></i>
                            </div>
                            <div title="${memberCountText}" class="member-info absolute bottom-0 right-0 w-3 h-3 rounded-full border-2 border-white bg-blue-500 flex items-center justify-center text-xs text-white">
                                <i class="fa fa-info"></i>
                            </div>
                        </div>
                        <span class="user-name ml-3 text-gray-800 font-semibold truncate flex-1">${group.group_name}</span>
                        ${badge}
                    </div>
                `;
            }).join('');

            document.querySelectorAll('.user-item[data-type="group"]').forEach(item => {
                item.addEventListener('click', () => {
                    startChat(item.dataset.id, 'group', item.dataset.name);
                });
            });
        }


        // --- CHAT MANAGEMENT ---
        function startChat(recipientId, type, recipientName) {
            if (messagePollInterval) clearInterval(messagePollInterval);
            currentRecipient = recipientId.toString();

            const displayName = type === 'user' ? recipientId : (recipientName || `Group ID: ${recipientId}`);
            recipientNameEl.textContent = displayName;

            // Enable input and send button
            toggleControls(false);

            // Control call buttons visibility/state based on chat type
            if (type === 'user') {
                voiceCallBtn.disabled = false;
                videoCallBtn.disabled = false;
                voiceCallBtn.classList.remove('opacity-50', 'pointer-events-none');
                videoCallBtn.classList.remove('opacity-50', 'pointer-events-none');
                addMemberBtn.classList.add('hidden');
            } else {
                voiceCallBtn.disabled = true; 
                voiceCallBtn.classList.add('opacity-50', 'pointer-events-none'); 
                
                videoCallBtn.disabled = true; 
                videoCallBtn.classList.add('opacity-50', 'pointer-events-none');
                
                addMemberBtn.classList.remove('hidden'); // Show add member button for groups
            }

            // Clear unread count for the new recipient
            unreadCounts[currentRecipient] = 0;
            renderSidebarContent(); // Re-render sidebar to clear badge

            // Hide sidebar on mobile when a chat is selected
            if (window.innerWidth < 1024) {
                document.getElementById('user-list-sidebar').classList.remove('open');
            }

            fetchMessages(); // Fetch initial history
            // Start polling for new messages
            messagePollInterval = setInterval(fetchMessages, POLL_RATE);

            // Mark messages as read after loading chat
            markMessagesAsRead(currentRecipient, type);
        }

        function showCreateGroupModal() {
            createGroupModal.classList.remove('hidden');
        }

        function showAddMemberModal() {
            const group = groupsList.find(g => g.group_id.toString() === currentRecipient);
            if (!group) return; // Should not happen if button is visible

            addMemberGroupNameEl.textContent = group.group_name;
            document.getElementById('add-member-modal').classList.remove('hidden');
        }

        async function fetchRegisteredUsers() {
            try {
                const response = await fetch('/api/users');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                registeredUserList = data.filter(user => user.username !== currentUsername); // Exclude self
                if (currentView === 'users') renderSidebarContent();
                console.log("Successfully fetched all registered users.");
            } catch (error) {
                console.error("Error fetching registered users:", error);
                if (currentView === 'users') sidebarListContainer.innerHTML = `<p class="text-red-500 p-4">Network error fetching users.</p>`;
            }
        }

        async function fetchGroups() {
            try {
                const response = await fetch(`/api/groups?username=${currentUsername}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                if (data.success) {
                    groupsList = data.groups || [];
                    if (currentView === 'groups') renderSidebarContent();
                    console.log(`Successfully fetched ${groupsList.length} groups.`);
                } else {
                    console.error("API error fetching groups:", data.message);
                }
            } catch (error) {
                console.error("Error fetching groups:", error);
                if (currentView === 'groups') {
                    sidebarListContainer.innerHTML = `<p class="text-red-500 p-4">Error loading groups. Ensure the server is running.</p>`;
                }
            }
        }

        async function fetchMessages() {
            if (!currentRecipient) return;

            try {
                const isGroup = groupsList.some(g => g.group_id.toString() === currentRecipient);
                let apiPath;
                if (isGroup) {
                    apiPath = `/api/messages/group/${currentRecipient}?username=${currentUsername}`;
                } else {
                    apiPath = `/api/messages/private/${currentRecipient}?username=${currentUsername}`;
                }

                const response = await fetch(apiPath);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status} - ${errorText.substring(0, 50)}...`);
                }

                const data = await response.json();
                
                if (Array.isArray(data)) {
                    renderMessages(data, isGroup);
                } else if (data.messages && Array.isArray(data.messages)) {
                    // Handle API response wrapping
                    renderMessages(data.messages, isGroup);
                } else {
                    // This could mean no messages, which is fine, or an unexpected format.
                    console.warn("Messages API returned unexpected data format:", data);
                    renderMessages([], isGroup); // Clear chat for safety
                }

                // Important: Update the view after a successful fetch to ensure
                // that read messages get visually marked as read on the server side
                // and the count is updated on the client.
                markMessagesAsRead(currentRecipient, isGroup ? 'group' : 'user');

            } catch (error) {
                console.error("Error fetching messages:", error);
                chatHistory.innerHTML = `<p class="text-center text-red-500 p-4">Error loading chat history. Please try again.</p>`;
            }
        }

        async function markMessagesAsRead(recipientId, type) {
            try {
                const isGroup = type === 'group';
                let apiPath = isGroup ? `/api/messages/group/read/${recipientId}` : `/api/messages/private/read/${recipientId}`;

                const response = await fetch(apiPath, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username: currentUsername })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                if (data.success) {
                    console.log(`${isGroup ? 'Group' : 'Private'} messages marked as read for ${recipientId}.`);
                    // This is where you might trigger a re-render of the sidebar if needed
                }
            } catch (error) {
                console.error("Error marking messages as read:", error);
            }
        }

        async function fetchUnreadCounts() {
            if (!currentUsername) return;
            try {
                const response = await fetch(`/api/messages/unread_counts?username=${currentUsername}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                if (data.success && data.counts) {
                    unreadCounts = data.counts;
                    // Only re-render if we are currently displaying one of the lists
                    if (currentView === 'users' || currentView === 'groups') {
                        renderSidebarContent();
                    }
                }
            } catch (error) {
                console.error("Error fetching unread counts:", error);
            }
        }

        // --- AUTH & INIT ---

        function checkSession() {
            if (!currentUsername) {
                loadingScreen.classList.add('hidden');
                loginRedirect.classList.remove('hidden');
                return;
            }

            currentUserDisplayEl.textContent = currentUsername;

            // Start initialization chain
            Promise.all([
                fetchCurrentUserId(currentUsername),
                fetchRegisteredUsers(),
                fetchGroups(),
                fetchUnreadCounts()
            ]).then(() => {
                // If initialization is successful, show the chat app
                loadingScreen.classList.add('hidden');
                chatApp.classList.remove('hidden');
            }).catch(error => {
                console.error("Initialization failed:", error);
                // Even on partial failure, hide loading and show app (with potential error messages in lists)
                loadingScreen.classList.add('hidden');
                chatApp.classList.remove('hidden');
            });

            // Start polling for unread counts
            setInterval(fetchUnreadCounts, POLL_RATE);
        }

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', checkSession);

        // --- API CALLS ---
        async function fetchCurrentUserId(username) {
            try {
                const response = await fetch(`/api/user/me?username=${username}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                if (data.success && data.user_id) {
                    currentUserId = data.user_id;
                    return true;
                } else {
                    console.error("Could not retrieve user ID:", data.message || 'Missing user_id');
                    return false;
                }
            } catch (error) {
                console.error("Error fetching user ID:", error);
                return false;
            }
        }

        async function createGroup(groupName, invitedUsernames) {
            try {
                const memberUsernames = invitedUsernames.split(',').map(u => u.trim()).filter(u => u.length > 0);
                if (!memberUsernames.includes(currentUsername)) {
                    memberUsernames.unshift(currentUsername);
                }

                const payload = {
                    groupName: groupName,
                    creatorUsername: currentUsername,
                    invitedUsernames: memberUsernames
                };

                const response = await fetch('/api/groups', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (response.ok && (data.group_id || data.groupId)) {
                    showToast(`Group "${groupName}" created successfully!`, 'success');
                    fetchGroups();
                    return true;
                } else {
                    showToast(`Failed to create group: ${data.message || 'Unknown error.'}`, 'error');
                    return false;
                }
            } catch (error) {
                console.error("Network error during group creation:", error);
                showToast("Network error: Could not connect to the server.", 'error');
                return false;
            }
        }

        async function addMembersToGroup(usernames) {
            const groupId = currentRecipient;
            const newMembers = usernames.split(',').map(u => u.trim()).filter(u => u.length > 0);

            if (newMembers.length === 0) {
                showToast("Please enter at least one username.", 'info');
                return false;
            }

            try {
                const payload = {
                    groupId: groupId,
                    usernames: newMembers,
                    adminUsername: currentUsername
                };

                const response = await fetch('/api/groups/add-members', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showToast(`Successfully added ${newMembers.length} member(s) to the group.`, 'success', 4000);
                    fetchGroups(); // Refresh group list to update member count/details
                    return true;
                } else {
                    showToast(`Failed to add members: ${data.message || 'Unknown error.'}`, 'error', 5000);
                    return false;
                }

            } catch (error) {
                console.error("Network error adding members:", error);
                showToast("Network error: Could not connect to the server.", 'error');
                return false;
            }
        }


        // --- EVENT LISTENERS ---
        document.getElementById('message-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const content = messageInput.value.trim();
            if (!content || !currentRecipient) return;

            toggleControls(true);
            messageInput.value = '';
            renderOptimisticMessage(content);

            const success = await postMessage(content);

            toggleControls(false);
            messageInput.focus();
            emojiPickerContainer.classList.add('hidden');
            filePickerContainer.classList.add('hidden');
        });

        document.getElementById('create-group-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const groupName = document.getElementById('group-name').value.trim();
            const invitedUsers = document.getElementById('group-invites').value.trim();

            if (groupName.length === 0) return;

            e.target.querySelector('button[type="submit"]').disabled = true;
            const success = await createGroup(groupName, invitedUsers);
            e.target.querySelector('button[type="submit"]').disabled = false;

            if (success) {
                document.getElementById('create-group-modal').classList.add('hidden');
                document.getElementById('group-name').value = '';
                document.getElementById('group-invites').value = '';
            }
        });

        document.getElementById('add-member-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const newMembers = document.getElementById('new-members-input').value.trim();

            if (newMembers.length === 0) return;

            e.target.querySelector('button[type="submit"]').disabled = true;
            const success = await addMembersToGroup(newMembers);
            e.target.querySelector('button[type="submit"]').disabled = false;

            if (success) {
                document.getElementById('add-member-modal').classList.add('hidden');
                document.getElementById('new-members-input').value = '';
            }
        });

        document.getElementById('logout-button').addEventListener('click', logout);

        function logout() {
            if (messagePollInterval) clearInterval(messagePollInterval);
            localStorage.removeItem('username');
            // Notify server of logout for proper disconnect handling
            socket.emit('user:logout', { username: currentUsername });
            window.location.href = '/';
        }

        // Mobile Sidebar Toggle
        document.getElementById('sidebar-open-mobile').addEventListener('click', () => {
            document.getElementById('user-list-sidebar').classList.add('open');
        });

        document.getElementById('sidebar-close-mobile').addEventListener('click', () => {
            document.getElementById('user-list-sidebar').classList.remove('open');
        });

        // Desktop Sidebar Minimized Toggle
        document.getElementById('sidebar-toggle-button').addEventListener('click', () => {
            document.getElementById('user-list-sidebar').classList.toggle('sidebar-minimized');
        });

        function setCurrentView(view) {
            currentView = view;
            document.getElementById('tab-users').classList.remove('active');
            document.getElementById('tab-groups').classList.remove('active');
            createGroupBtn.classList.add('hidden');

            if (view === 'users') {
                document.getElementById('tab-users').classList.add('active');
            } else if (view === 'groups') {
                document.getElementById('tab-groups').classList.add('active');
                createGroupBtn.classList.remove('hidden');
            }
            renderSidebarContent();
        }


        // --- SOCKET.IO LISTENERS ---
        socket.on('connect', () => {
            console.log("Connected to Socket.IO server.");
            if (currentUsername) {
                socket.emit('user:online', { username: currentUsername });
            }
        });

        // Updates the list of currently online users
        socket.on('users:online:list', (onlineUsernames) => {
            onlineUsernamesList = onlineUsernames;
            // Only re-render if the user list is currently visible
            if (currentView === 'users') {
                renderSidebarContent();
            }
        });

        // Called when a new private message is received
        socket.on('chat:new_message', (data) => {
            // data: { from: senderUsername, content: '...', timestamp: '...' }
            if (data.from === currentRecipient) {
                // If the message is from the current chat, fetch the latest to render
                fetchMessages();
                markMessagesAsRead(currentRecipient, 'user');
            } else {
                // If the message is from another chat, increment unread count
                unreadCounts[data.from] = (unreadCounts[data.from] || 0) + 1;
                showToast(`New message from ${data.from}: ${data.content}`, 'info', 4000);
                renderSidebarContent();
            }
        });

        // Called when a new group message is received
        socket.on('group:new_message', (data) => {
            // data: { groupId: id, senderUsername: '...', content: '...', timestamp: '...' }
            const groupId = data.groupId.toString();
            if (groupId === currentRecipient) {
                // If the message is for the current group, fetch the latest to render
                fetchMessages();
                markMessagesAsRead(groupId, 'group');
            } else {
                // If the message is for another group, increment unread count
                unreadCounts[groupId] = (unreadCounts[groupId] || 0) + 1;
                showToast(`New group message in ${groupsList.find(g => g.group_id.toString() === groupId)?.group_name || 'a group'}`, 'info', 4000);
                renderSidebarContent();
            }
        });

        // --- NEW CALL LISTENERS ---

        // Called on the RECIPIENT's side
        socket.on('call:incoming', (data) => {
            // data: { from: callerUsername, type: 'voice' | 'video' }
            if (callState.active) {
                // Busy: immediately send a busy signal or end call
                socket.emit('call:end', { to: data.from, from: currentUsername });
                showToast(`Missed incoming ${data.type} call from ${data.from}. (Busy)`, 'error', 5000);
                return;
            }
            // Show the UI and enable the 'Accept' button for user input
            showCallUI(data.from, data.type, true);
        });

        // Called on the CALLER's side
        socket.on('call:unavailable', (data) => {
            // data: { to: recipientUsername, type: 'voice' | 'video' }
            hideCallUI(`User ${data.to} is currently offline.`, 'error');
        });

        // Called on both sides when the other user hangs up
        socket.on('call:ended', (data) => {
            // data: { from: otherUserUsername }
            if (callState.active && (callState.recipient === data.from || currentRecipient === data.from)) {
                hideCallUI(`Call ended by ${data.from}.`, 'info');
            } else {
                // This might be a busy signal or a general notification
                console.log(`Call end signal received from ${data.from}, but not in an active call with them.`);
            }
        });

        // NEW: Signal to the caller that the recipient is ready to receive the offer/re-send
        socket.on('call:ready_to_receive', async (data) => {
            if (peerConnection && localStream && callState.active && currentRecipient === data.from) {
                try {
                    // Caller re-sends the offer (or sends it again if the initial one was only signaling intent)
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);

                    socket.emit('call:offer', {
                        to: data.from,
                        from: currentUsername,
                        sdp: peerConnection.localDescription
                    });
                    console.log(`Re-sent SDP offer to ${data.from}.`);
                } catch (error) {
                    console.error("Error re-sending offer:", error);
                    hideCallUI("Error during call setup.", 'error', 5000);
                }
            }
        });


        // --- NEW WebRTC Signaling Listeners ---

        // Called on RECIPIENT side after ACCEPT (when the caller sends the offer)
        socket.on('call:offer', async (data) => {
            // data: { sdp: RTCSessionDescription, from: callerUsername }
            console.log(`Received WebRTC offer from ${data.from}`);

            // Ensure PC is set up (should be done on accept click)
            if (!peerConnection || callState.recipient !== data.from) {
                console.error("PC not set up or call mismatch for offer.");
                return;
            }

            try {
                // 1. Set the remote description (the offer)
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));

                // 2. Create the answer
                const answer = await peerConnection.createAnswer();

                // 3. Set the local description (the answer)
                await peerConnection.setLocalDescription(answer);

                // 4. Send the answer back to the caller
                socket.emit('call:answer', {
                    to: data.from,
                    from: currentUsername,
                    sdp: peerConnection.localDescription
                });

            } catch (error) {
                console.error("Error processing offer and sending answer:", error);
                hideCallUI("Error establishing call connection.", 'error', 5000);
            }
        });

        // Called on CALLER side after RECIPIENT answers
        socket.on('call:answer', async (data) => {
            // data: { sdp: RTCSessionDescription, from: recipientUsername }
            console.log(`Received WebRTC answer from ${data.from}`);

            // Ensure PC is set up
            if (!peerConnection || currentRecipient !== data.from) return;

            try {
                // Set the remote description (the answer)
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));

            } catch (error) {
                console.error("Error processing answer:", error);
            }
        });

        // Called on both sides to exchange network information
        socket.on('ice:candidate', async (data) => {
            // data: { candidate: RTCIceCandidate, from: otherUsername }
            console.log(`Received ICE candidate from ${data.from}`);

            // Ensure PC is set up
            if (!peerConnection || (currentRecipient !== data.from && callState.recipient !== data.from)) return;

            try {
                const candidate = new RTCIceCandidate(data.candidate);
                // Add the candidate to the RTCPeerConnection
                await peerConnection.addIceCandidate(candidate);

            } catch (error) {
                // This is often a non-critical error if a candidate is received before setRemoteDescription
                console.warn("Error adding received ICE candidate:", error);
            }
        });

    </script>
</body>
</html>